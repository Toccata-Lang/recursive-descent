
(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "43bc6f4"))
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "77a3dfa"))

(deftype ParserState [curr-input input values]
  (assert (instance? String curr-input))
  (assert (instance? HashMap values))

  Stringable
  (string-list [_] (list "<ParserState>"))

  Collection
  (empty? [_]
    (and (empty? curr-input)
         (empty? input))))

(defn next-input-buffer [s]
  (assert (instance? ParserState s))
  (let [input (.input s)]
    (for [new-text (first input)]
      (-> s
          (.curr-input new-text)
          (.input (either (empty? new-text)
                          (rest input)))))))

(defn reader [n s]
  (assert (instance? ParserState s))

  (let [text (.curr-input s)
        text-length (count text)]
    (or (and (< n text-length)
             (maybe [(subs text 0 n)
                     (.curr-input s (subs text n))]))
        (and (= n text-length)
             (or (map (next-input-buffer s)
                      (fn [new-s]
                        [text new-s]))
                 (maybe [text (.curr-input s "")])))
        ;; (< text-length n)
        (flat-map (next-input-buffer s)
                  (fn [new-s]
                    (let [next-read (reader (- n text-length) new-s)]
                      (and next-read (let [[texts final-s] (extract next-read)]
                                       (maybe [(comp text texts) final-s])))))))))

(deftype ParserFail []
  Stringable
  (string-list [_]
    (list "(ParserFail)"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))
(def parser-fail (ParserFail))

(deftype ParserMatch [value state]
  Stringable
  (string-list [_]
    (list "(ParserMatch " (str value) "\n" (str state) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ParserIgnore [state]
  Stringable
  (string-list [_]
    (list "(ParserIgnore " (str state) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ParserError [msg state]
  Stringable
  (string-list [_]
    (list "(ParserError " (str msg) "\n" (str state) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(defprotocol Parser
  (terminate-string [s]
    s)
  
  (make-parser [r]
    (assert-result r (instance? se/StateError r))
    (se/state-error r))

  (collapse-branches [r]
    r)

  (parse [r state]
    (assert (instance? ParserState state))))

(extend-type Promise
  Parser
  (parse [p state]
    (cond (delivered p)
          (parse (extract p) state)

          (ParserError (str "Invalid parser " _FILE_ " " _LINE_) state))))

(extend-type String
  Parser
  (terminate-string [s]
    (grmr/parser-terminal s))
  
  (make-parser [s]
    (se/state-error (grmr/term s))))

(extend-type grmr/parser-terminal
  Parser
  (parse [r state]
    (let [term-str (.term-str r)
          term-count (count term-str)]
      (either (for [[text new-state] (reader term-count state)
                    :when (= text term-str)]
                (ParserMatch term-str new-state))
              parser-fail))))

(extend-type grmr/parser-not-char
  Parser
  (parse [r state]
    (let [test-c (.test-c r)]
      (either (for [[c new-state] (reader 1 state)
                    :when-not (= c test-c)]
                (ParserMatch c new-state))
              parser-fail))))

(extend-type grmr/parser-always
  Parser
  (parse [r state]
    (ParserMatch (.value r) state)))

(extend-type grmr/parser-apply
  Parser
  (parse [r state]
    (cond (empty? (.args r))
          (ParserError (str "Invalid parser " _FILE_ " " _LINE_) state)

          (let [f-and-args (reduce (comp [(.pf r)] (.args r))
                                   (ParserMatch [] state)
                                   (fn [result inner-r]
                                     (cond (instance? ParserMatch result)
                                           (let [inner-result (parse inner-r (.state result))]
                                             (cond (instance? ParserMatch inner-result)
                                                   (ParserMatch (conj (.value result)
                                                                      (.value inner-result))
                                                                (.state inner-result))

                                                   (instance? ParserIgnore inner-result)
                                                   (ParserMatch (.value result)
                                                                (.state inner-result))

                                                   inner-result))

                                           result)))]
            (cond (instance? ParserMatch f-and-args)
                  (let [[f & args] (.value f-and-args)]
                    (.value f-and-args (apply f args)))

                  f-and-args)))))

(extend-type grmr/none-or-more-rule
  Parser
  (collapse-branches [r]
    (let [p (promise)
          new-r (grmr/any (grmr/parser-apply (grmr/parser-always (fn [x v]
                                                                   (conj v x)))
                                             [(.rule r)
                                              (grmr/any p
                                                        (grmr/always empty-list))])
                          (grmr/always empty-list))]
      (deliver p new-r)
      new-r)))

(extend-type grmr/repeat-rule
  Parser
  (collapse-branches [r]
    (let [p (promise)
          new-r (grmr/parser-apply (grmr/parser-always (fn [x v]
                                                         (conj v x)))
                                   [(.rule r)
                                    (grmr/any p
                                              (grmr/always empty-list))])]
      (deliver p new-r)
      new-r)))

(extend-type grmr/parser-rule
  Parser
  (parse [r s]
    (ParserError (str "Un-collapsed rule " (.name r))
                 s))

  (collapse-branches [r]
    (cond (instance? grmr/recursion-rule (.name r))
          (deliver (.prom (.name r)) (.grammar r))
          '_)
    (.grammar r)))

(extend-type grmr/recursion-rule
  Parser
  (collapse-branches [r]
    (.prom r))

  (make-parser [r]
    (comp (map (se/get-val (.rule-name r))
               (partial .prom r))
          (map (se/set-val (.rule-name r) (.prom r))
               (fn [_]
                 r)))))

(extend-type grmr/All-rule
  Parser
  (make-parser [r]
    (-> (.rules r)
        reverse
        (reduce empty-list (fn [l r]
                             (cond (instance? grmr/Any-rule r)
                                   (list (map r (fn [inner-r]
                                                  (grmr/All-rule (comp [inner-r] l)))))

                                   (instance? grmr/All-rule r)
                                   (comp (.rules r) l)

                                   (conj l r))))
        vec
        grmr/All-rule
        se/state-error))

  (collapse-branches [r]
    (either (and (= 1 (count (.rules r)))
                 (first (.rules r)))

            (-> (.rules r)
                (reduce [] (fn [v inner-r]
                             (cond (instance? grmr/All-rule inner-r)
                                   (comp v (.rules inner-r))

                                   (conj v inner-r))))
                grmr/All-rule)))

  (parse [r state]
    (cond (empty? (.rules r))
          (ParserError (str "Invalid parser " _FILE_ " " _LINE_) state)

          (reduce (.rules r) (ParserMatch [] state)
                  (fn [results inner-r]
                    (cond (or (instance? ParserIgnore results)
                              (instance? ParserMatch results))
                          (let [inn-res (parse inner-r (.state results))]
                            (cond (instance? ParserMatch inn-res)
                                  (.value inn-res (conj (.value results) (.value inn-res)))

                                  (instance? ParserIgnore inn-res)
                                  (.state results (.state inn-res))

                                  inn-res))

                          results))))))

(extend-type grmr/Any-rule
  Parser
  (collapse-branches [r]
    (either (and (= 1 (count (.rules r)))
                 (first (.rules r)))

            (-> (.rules r)
                (reduce [] (fn [v inner-r]
                             (cond (instance? grmr/Any-rule inner-r)
                                   (comp v (.rules inner-r))

                                   (conj v inner-r))))
                grmr/Any-rule)))

  (parse [r state]
    (cond (empty? (.rules r))
          (ParserError (str "Invalid parser " _FILE_ " " _LINE_) state)

          (reduce (.rules r) parser-fail
                  (fn [result inner-r]
                    (either (or (instance? ParserError result)
                                (instance? ParserMatch result)
                                (instance? ParserIgnore result))

                            (parse inner-r state)))))))

(extend-type grmr/ignore-rule
  Parser
  (parse [r state]
    (let [result (parse (.rule r) state)]
      (cond (instance? ParserMatch result)
            (ParserIgnore (.state result))

            result))))

(extend-type grmr/parser-char-range
  Parser
  (parse [r state]
    (either (for [[c new-state] (reader 1 state)
                  :when (< (dec (char-code (.lower r)))
                           (char-code c)
                           (inc (char-code (.higher r))))]
              (ParserMatch c new-state))
            parser-fail)))

(extend-type grmr/get-state-value
  Parser
  (parse [r state]
    (either (map (get-in state [.values (.key r)])
                 (fn [val]
                   (ParserMatch val state)))
            (ParserError (str "No value for key '" (.key r) "' found.")
                         state))))

(extend-type grmr/update-state-value
  Parser
  (parse [r state]
    (either (map (get-in state [.values (.key r)])
                 (fn [val]
                   (ParserMatch val (assoc-in state [.values (.key r)] ((.f r) val)))))
            (ParserError (str "No value for key '" (.key r) "' found.")
                         state))))

(extend-type grmr/parser-get-text
  Parser
  (parse [r state]
    (either (map (get state .curr-input)
                 (fn [val]
                   (ParserMatch val state)))
            (ParserError "Invalid state. Missing .curr-input"
                         state))))

(defn fn-reader [f s]
  (assert (instance? Fn f))
  (assert (instance? ParserState s))

  (let [text (.curr-input s)
        length (f text)]
    (or (and (or (= length (count text)))
             (for [new-s (next-input-buffer s)
                   [tail final-s] (fn-reader f new-s)]
               [(cons text tail) final-s]))
        (and (< 0 length)
             (maybe [(list (subs text 0 length))
                     (.curr-input s (subs text length))])))))

(extend-type grmr/parser-term-fn
  Parser
  (parse [p s]
    (either (for [[str-list new-s] (fn-reader (.f p) s)]
              (let [line-count (reduce str-list 0
                                       (fn [line-count s]
                                         (reduce s line-count
                                                 (fn [line-count c]
                                                   (+ line-count (either (and (= c "\n")
                                                                              (maybe 1))
                                                                         0))))))]
                (ParserMatch (to-str str-list)
                             (either (update-in new-s [.values 'line-number]
                                                (fn [lc] (+ lc line-count)))
                                     (assoc-in new-s [.values 'line-number] line-count)))))
            parser-fail)))

(extend-type grmr/error-value
  Parser
  (parse [p state]
    (ParserError (.msg p) state)))

(defprotocol WrapInput
  (wrap-input [x]
    x))

(extend-type String
  WrapInput
  (wrap-input [x] (list x)))

(defn parser [grammar]
  (let [grammar (ana terminate-string grammar)
        [raw] ((cata make-parser grammar se/state-error) {})
        grammar-parser (cata collapse-branches raw)]
    (fn
      ([input]
       (parse grammar-parser (ParserState "" (wrap-input input) {})))
      ([values input]
       (parse grammar-parser (ParserState "" (wrap-input input) values))))))

;; TODO: may no longer be correct after switching to state-error
;; (defn parse-stream
;;   ([s grammar] (parse-stream s grammar {}))
;;   ([s grammar values]
;;    (let [grammar (grmr/string-terminal grammar)
;;          [grammar-parser recursive-rules] ((fr/evaluate grammar recursive-descent) {})]
;;      (st/state-stream (ParserState "" s recursive-rules values)
;;                       (fn [stream-state]
;;                         (either (grammar-parser stream-state)
;;                                 ["" (ParserState "" st/empty-stream recursive-rules values)]))))))
